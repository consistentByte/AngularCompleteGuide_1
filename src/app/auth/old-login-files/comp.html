<!-- To get acess to this form, either use ViewChild or pass it via method when form is submitted -->
<form #form="ngForm" (ngSubmit)="onSubmit(form)">
  <h2>Login</h2>

  <div class="control-row">
    <div class="control no-margin">
      <label for="email">Email</label>
      <input
        id="email"
        type="email"
        name="email"
        ngModel
        email
        required
        #emailCtrl="ngModel"
      />
    </div>

    <div class="control no-margin">
      <label for="password">Password</label>
      <input
        id="password"
        type="password"
        name="password"
        ngModel
        minlength="6"
        required
        #passwordCtrl="ngModel"
      />
    </div>

    <button type="submit" class="button">Login</button>
  </div>

  <!-- @if(form.form.controls['email'].touched &&
  form.form.controls['password'].touched && form.form.invalid){ -->
  @if(emailCtrl.touched && emailCtrl.dirty && emailCtrl.invalid ) {
  <p class="control-error">Invalid email address entered.</p>
  } @if(passwordCtrl.touched && passwordCtrl.dirty && passwordCtrl.invalid ) {
  <p class="control-error">Invalid password entered.</p>
  }
</form>
<!-- Template driven form as the setup we did is in the template -->
<!-- End goal is to make angular aware of the form and its inputs. -->
<!-- using ngModel without two-way binding.
 The ngModel directive registers an html element with Angular. By registering the element, Angular becomes aware of it and manages it behind the scenes. This also allows you to access the element programmatically.
 
If ngModel is used within a form tag, either the name attribute must be set or the form.
name is internally used by angular to register the element and get managed by angular.

However, currently, there is no way to access this form that is handled by Angular, nor to get hold of the input elements registered with Angular.
So to access the form (HTMLFormElement from DOM) we can add a template variable to the form.

Here we want to get the formobject created by angular and managed behind the scenes.


1 ] #form (without ="ngForm")

This gives you the native HTMLFormElement (basically what document.querySelector('form') would return).

You can still access raw properties:

form.action

form.submit()

form.elements

But you don’t get Angular’s validation state or reactive tracking.

2 ] #form="ngForm"

This doesn’t give you the raw DOM element.

It gives you the Angular NgForm directive instance that Angular attaches to the <form>.

That object has Angular goodies like:

form.value → an object with all registered control values.

form.valid / form.invalid → form-wide validation state.

form.controls → a map of individual controls (email, etc.).

Why Angular prefers ngForm

If you just grab the DOM object, you’re bypassing Angular’s entire form management system.

No automatic validation states.

No control grouping.

No form.value snapshot.

With ngForm, Angular stays in sync between template, model, and validation, so you’re working with Angular’s ecosystem rather than the raw browser form.

Why using ngModel without two way binding?
When you write:

<input id="email" type="email" name="email" ngModel />


ngModel registers this input as a form control inside the NgForm.

Without [()] (banana in a box), you’re not doing two-way binding with a component property.

Instead, Angular just tracks it inside the form and includes it in form.value.

Example:

onSubmit(form: NgForm) {
  console.log(form.value.email); // works even without [(ngModel)]
}


If you wanted to sync this input directly to a component property, then you’d use:

<input [(ngModel)]="userEmail" name="email">


So here, since the goal is form-driven data collection (not syncing to a property), one-way ngModel (registration only) is enough.

Why is the name attribute important here?

In template-driven forms, name is how Angular identifies and registers controls inside the form.

Without name, Angular will ignore the input—it won’t appear in form.value or in validation checks.

Example:

<input id="email" type="email" ngModel />  Won’t be part of form.value 
<input id="email" type="email" name="email" ngModel />  Will be part of form.value.email 


So name is basically the key under which the control is stored in the form’s internal structure.

#form="ngForm" → gets Angular’s form API, not just the HTML element.

ngModel (without two-way binding) → just registers the field with Angular’s form model.

name → mandatory for Angular to include the control in form.value.

---------------------------------------------------------------------------

Using required lets us browser do some validation 
but when using required with an element registered with ngModel, angular takes over and disable browser built-in validation and instead validation it internally.
This is because required is essentially registered as a directive in angular.

email is also a directive registered on angular to do basic validation whether value is email
similarly minlength, maxlength,and pattern are also basic directives used to do respective validation checks.

-->

<!-- 


form.form.controls['email'].touched &&
  form.form.controls['password'].touched && form.form.invalid 
  
this check can be used to check if both form inputs are touched and still invalid.
  But its too verbose for use in template.


What does #emailCtrl="ngModel" mean?

Here, you’re creating a template reference variable named emailCtrl.

By writing ="ngModel", you’re telling Angular:

“Instead of pointing to the raw HTML element, give me the NgModel directive instance applied on this element.”

So:

<input id="email" type="email" name="email" ngModel #emailCtrl="ngModel" />


emailCtrl now refers to the NgModel instance, which exposes control-specific properties, like:

emailCtrl.value → current input value

emailCtrl.valid → whether the field is valid

emailCtrl.touched → if the user has interacted

emailCtrl.dirty → if the value has changed


So basically #emailCtrl="ngModel" gives you direct access to the state of this input control.
Without the "ngModel" part: #emailCtrl would just point to the raw <input> DOM element

#emailCtrl="ngModel" is Angular’s way of letting you inspect and react to the validation state/value of a single field directly inside the template.
-->

<!-- 
Marking invalid inputs as invalid visually: 

Angular's Automatic CSS Classes for Inputs
Angular helps us visually mark invalid inputs. If you inspect an input field registered with ng-model, you will see special CSS classes added to it. These classes are managed by Angular because of the ng-model directive on that input.

The key classes added by Angular are:

ng-pristine: Indicates whether the input has received any user input. If this class is present, the input has not been modified.
ng-invalid: Indicates whether the input is currently invalid. If the input is valid, this class is replaced by ng-valid.
ng-touched: Indicates whether the user has selected or focused on the input at least once.
ng-untouched, ng-valid and etc.

.dirty is true, if user entered some value but it does not pass validation check.
-->
